# .github/workflows/update-status.yml
name: Update Service Status with Teams Alerts

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch: # Allow manual trigger
  push:
    branches: [main]

jobs:
  update-status:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Install dependencies
      run: |
        npm init -y
        npm install cheerio axios
    
    - name: Check service statuses and send alerts
      env:
        TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      run: |
        cat > check-status-with-alerts.js << 'EOF'
        const axios = require('axios');
        const cheerio = require('cheerio');
        const fs = require('fs');

        // Configure axios with better defaults
        axios.defaults.timeout = 15000;
        axios.defaults.headers['User-Agent'] = 'Mozilla/5.0 (compatible; StatusBot/1.0)';

        // Teams webhook URL from environment
        const TEAMS_WEBHOOK_URL = process.env.TEAMS_WEBHOOK_URL;

        // Helper functions
        function mapStatusPageIndicator(indicator) {
          switch (indicator) {
            case 'none':
              return 'operational';
            case 'minor':
              return 'degraded';
            case 'major':
            case 'critical':
              return 'outage';
            default:
              return 'unknown';
          }
        }

        function createErrorStatus(name, displayName) {
          return {
            name: name,
            displayName: displayName,
            status: 'unknown',
            description: 'Failed to fetch official status',
            lastChecked: new Date().toISOString()
          };
        }

        // Teams notification functions
        function getStatusColor(status) {
          switch (status) {
            case 'operational': return 'Good';
            case 'degraded': return 'Warning';
            case 'outage': return 'Attention';
            default: return 'Default';
          }
        }

        function getStatusEmoji(status) {
          switch (status) {
            case 'operational': return 'ðŸŸ¢';
            case 'degraded': return 'ðŸŸ¡';
            case 'outage': return 'ðŸ”´';
            default: return 'âšª';
          }
        }

        async function sendTeamsAlert(type, service, oldStatus = null) {
          if (!TEAMS_WEBHOOK_URL) {
            console.log('No Teams webhook URL configured, skipping alert');
            return;
          }

          let title, text, color, activity;

          if (type === 'down') {
            title = `ðŸš¨ Service Alert: ${service.displayName}`;
            text = `**${service.displayName}** is experiencing issues`;
            color = getStatusColor(service.status);
            activity = {
              activityTitle: 'Service Status Change',
              activitySubtitle: `${oldStatus} â†’ ${service.status}`,
              activityImage: 'https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/assets/Alert/SVG/ic_fluent_alert_24_filled.svg'
            };
          } else if (type === 'recovered') {
            title = `âœ… Service Recovered: ${service.displayName}`;
            text = `**${service.displayName}** is back to normal`;
            color = 'Good';
            activity = {
              activityTitle: 'Service Recovery',
              activitySubtitle: `${oldStatus} â†’ ${service.status}`,
              activityImage: 'https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/assets/Checkmark/SVG/ic_fluent_checkmark_24_filled.svg'
            };
          } else if (type === 'summary') {
            const issueCount = service.issueCount || 0;
            const totalServices = service.totalServices || 0;
            
            if (issueCount === 0) {
              title = 'âœ… All Systems Operational';
              text = `All ${totalServices} monitored services are running normally`;
              color = 'Good';
            } else {
              title = `âš ï¸ Service Issues Detected`;
              text = `${issueCount} out of ${totalServices} services experiencing issues`;
              color = 'Warning';
            }
            
            activity = {
              activityTitle: 'Status Summary',
              activitySubtitle: new Date().toLocaleString(),
              activityImage: 'https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/assets/Status/SVG/ic_fluent_status_24_filled.svg'
            };
          }

          const teamsMessage = {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": title,
            "themeColor": color === 'Good' ? '28a745' : color === 'Warning' ? 'ffc107' : 'dc3545',
            "sections": [
              {
                "activityTitle": title,
                "activitySubtitle": new Date().toLocaleString('en-US', {
                  timeZone: 'UTC',
                  year: 'numeric',
                  month: 'short',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                  timeZoneName: 'short'
                }),
                "activityImage": "https://img.icons8.com/fluency/48/000000/server.png",
                "facts": type !== 'summary' ? [
                  {
                    "name": "Service",
                    "value": service.displayName
                  },
                  {
                    "name": "Status",
                    "value": `${getStatusEmoji(service.status)} ${service.status.charAt(0).toUpperCase() + service.status.slice(1)}`
                  },
                  {
                    "name": "Description",
                    "value": service.description || 'No additional details available'
                  }
                ] : [
                  {
                    "name": "Services Monitored",
                    "value": service.totalServices.toString()
                  },
                  {
                    "name": "Issues Detected",
                    "value": service.issueCount.toString()
                  },
                  {
                    "name": "Last Updated",
                    "value": new Date().toLocaleString()
                  }
                ],
                "text": text
              }
            ],
            "potentialAction": [
              {
                "@type": "OpenUri",
                "name": type !== 'summary' ? "View Status Page" : "View Full Dashboard",
                "targets": [
                  {
                    "os": "default",
                    "uri": type !== 'summary' ? 
                      getStatusPageUrl(service.name) : 
                      "https://hritikch24.github.io/statuspage/"
                  }
                ]
              }
            ]
          };

          try {
            await axios.post(TEAMS_WEBHOOK_URL, teamsMessage, {
              headers: { 'Content-Type': 'application/json' }
            });
            console.log(`Teams alert sent: ${title}`);
          } catch (error) {
            console.error('Failed to send Teams alert:', error.message);
          }
        }

        function getStatusPageUrl(serviceName) {
          const urls = {
            confluent: 'https://status.confluent.cloud/',
            cloudflare: 'https://www.cloudflarestatus.com/',
            nylas: 'https://status-v3.nylas.com/',
            sendgrid: 'https://status.sendgrid.com/',
            twilio: 'https://status.twilio.com/',
            postmark: 'https://status.postmarkapp.com/',
            zohomail: 'https://status.zoho.com/',
            mailgun: 'https://status.mailgun.com/'
          };
          return urls[serviceName] || 'https://hritikch24.github.io/statuspage/';
        }

        // Service check functions (same as before)
        async function checkConfluentStatus() {
          console.log('Checking Confluent Cloud...');
          try {
            const response = await axios.get('https://status.confluent.cloud/api/v2/status.json');
            return {
              name: 'confluent',
              displayName: 'Confluent Cloud',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Confluent check failed:', error.message);
            return createErrorStatus('confluent', 'Confluent Cloud');
          }
        }

        async function checkCloudflareStatus() {
          console.log('Checking Cloudflare...');
          try {
            const response = await axios.get('https://www.cloudflarestatus.com/api/v2/status.json');
            return {
              name: 'cloudflare',
              displayName: 'Cloudflare',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Cloudflare check failed:', error.message);
            return createErrorStatus('cloudflare', 'Cloudflare');
          }
        }

        async function checkNylasStatus() {
          console.log('Checking Nylas...');
          try {
            const response = await axios.get('https://status-v3.nylas.com/');
            const $ = cheerio.load(response.data);
            const pageText = response.data.toLowerCase();
            
            console.log('Nylas: Analyzing official status page...');
            
            const currentIncidentKeywords = [
              'investigating -', 'investigating:', 
              'identified -', 'identified:',
              'reopened:', 'reopened -',
              'elevated error', 'elevated 504', 'elevated 502'
            ];
            
            for (const keyword of currentIncidentKeywords) {
              if (pageText.includes(keyword)) {
                console.log(`Nylas: Found active incident keyword: ${keyword}`);
                if (keyword.includes('investigating') || keyword.includes('identified')) {
                  return {
                    name: 'nylas',
                    displayName: 'Nylas',
                    status: 'outage',
                    description: 'Currently investigating service issues',
                    lastChecked: new Date().toISOString()
                  };
                } else {
                  return {
                    name: 'nylas',
                    displayName: 'Nylas',
                    status: 'degraded',
                    description: 'Active service issues detected',
                    lastChecked: new Date().toISOString()
                  };
                }
              }
            }
            
            if (pageText.includes('monitoring -') || pageText.includes('monitoring:')) {
              return {
                name: 'nylas',
                displayName: 'Nylas',
                status: 'degraded',
                description: 'Service issues being monitored',
                lastChecked: new Date().toISOString()
              };
            }
            
            const recentDates = ['jul 31', 'jul 30', 'jul 29', 'july 31', 'july 30', 'july 29'];
            const hasRecentActivity = recentDates.some(date => pageText.includes(date));
            
            if (hasRecentActivity && (pageText.includes('error') || pageText.includes('issue'))) {
              return {
                name: 'nylas',
                displayName: 'Nylas',
                status: 'degraded',
                description: 'Recent service issues or errors detected',
                lastChecked: new Date().toISOString()
              };
            }
            
            return {
              name: 'nylas',
              displayName: 'Nylas',
              status: 'operational',
              description: 'No active incidents detected',
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Nylas check failed:', error.message);
            return createErrorStatus('nylas', 'Nylas');
          }
        }

        async function checkSendGridStatus() {
          console.log('Checking SendGrid...');
          try {
            const response = await axios.get('https://status.sendgrid.com/api/v2/status.json');
            return {
              name: 'sendgrid',
              displayName: 'SendGrid',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('SendGrid check failed:', error.message);
            return createErrorStatus('sendgrid', 'SendGrid');
          }
        }

        async function checkTwilioStatus() {
          console.log('Checking Twilio...');
          try {
            const response = await axios.get('https://status.twilio.com/api/v2/status.json');
            return {
              name: 'twilio',
              displayName: 'Twilio Communications',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Twilio check failed:', error.message);
            return createErrorStatus('twilio', 'Twilio Communications');
          }
        }

        async function checkPostmarkStatus() {
          console.log('Checking Postmark...');
          try {
            try {
              const response = await axios.get('https://status.postmarkapp.com/api/v1/page');
              const data = response.data;
              
              console.log('Postmark API response:', JSON.stringify(data, null, 2));
              
              let status = 'operational';
              let description = data.page?.state_text || 'All systems operational';
              
              switch (data.page?.state) {
                case 'operational':
                  status = 'operational';
                  break;
                case 'degraded':
                  status = 'degraded';
                  break;
                case 'maintenance':
                  status = 'degraded';
                  description = 'Scheduled maintenance in progress';
                  break;
                case 'outage':
                  status = 'outage';
                  break;
                default:
                  status = 'operational';
                  description = 'All systems operational';
                  break;
              }
              
              return {
                name: 'postmark',
                displayName: 'Postmark',
                status: status,
                description: description,
                lastChecked: new Date().toISOString()
              };
            } catch (apiError) {
              console.log('Postmark API failed, trying HTML:', apiError.message);
              
              const response = await axios.get('https://status.postmarkapp.com/');
              const $ = cheerio.load(response.data);
              const pageText = response.data.toLowerCase();
              const pageTitle = $('title').text().toLowerCase();
              
              console.log('Postmark page title:', pageTitle);
              
              if (pageTitle.includes('all systems are go') || 
                  pageTitle.includes('operational') ||
                  pageText.includes('all systems are go')) {
                return {
                  name: 'postmark',
                  displayName: 'Postmark',
                  status: 'operational',
                  description: 'All systems are go!',
                  lastChecked: new Date().toISOString()
                };
              } else if (pageText.includes('investigating') || pageText.includes('identified')) {
                return {
                  name: 'postmark',
                  displayName: 'Postmark',
                  status: 'outage',
                  description: 'Service issues detected',
                  lastChecked: new Date().toISOString()
                };
              } else if (pageText.includes('monitoring') || pageText.includes('degraded')) {
                return {
                  name: 'postmark',
                  displayName: 'Postmark',
                  status: 'degraded',
                  description: 'Service partially affected',
                  lastChecked: new Date().toISOString()
                };
              }
              
              return {
                name: 'postmark',
                displayName: 'Postmark',
                status: 'operational',
                description: 'Status page accessible',
                lastChecked: new Date().toISOString()
              };
            }
          } catch (error) {
            console.error('Postmark check failed:', error.message);
            return createErrorStatus('postmark', 'Postmark');
          }
        }

        async function checkZohoMailStatus() {
          console.log('Checking Zoho Mail...');
          try {
            const response = await axios.get('https://status.zoho.com/sp/api/u/status');
            const data = response.data;
            
            console.log('Zoho API response:', JSON.stringify(data, null, 2));
            
            let status = 'operational';
            let description = 'All systems operational';
            
            if (data.result && Array.isArray(data.result)) {
              const mailIssues = data.result.filter(item => 
                item.name && item.name.toLowerCase().includes('mail')
              );
              
              if (mailIssues.length > 0) {
                const mailIssue = mailIssues[0];
                if (mailIssue.status) {
                  switch (mailIssue.status.toLowerCase()) {
                    case 'down':
                    case 'outage':
                      status = 'outage';
                      description = 'Mail service is down';
                      break;
                    case 'degraded':
                    case 'issues':
                      status = 'degraded';
                      description = 'Mail service experiencing issues';
                      break;
                    default:
                      status = 'operational';
                      description = 'Mail service operational';
                  }
                }
              }
            }
            
            if (data.status) {
              switch (data.status.toLowerCase()) {
                case 'down':
                case 'outage':
                  status = 'outage';
                  description = 'Zoho services experiencing outages';
                  break;
                case 'degraded':
                case 'issues':
                  status = 'degraded';
                  description = 'Zoho services experiencing issues';
                  break;
                default:
                  status = 'operational';
                  description = 'All Zoho services operational';
              }
            }
            
            return {
              name: 'zohomail',
              displayName: 'Zoho Mail',
              status: status,
              description: description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Zoho Mail check failed:', error.message);
            console.error('Error details:', error.response?.data || error.message);
            return createErrorStatus('zohomail', 'Zoho Mail');
          }
        }

        async function checkMailgunStatus() {
          console.log('Checking Mailgun...');
          try {
            try {
              const response = await axios.get('https://status.mailgun.com/api/v2/status.json');
              return {
                name: 'mailgun',
                displayName: 'Mailgun',
                status: mapStatusPageIndicator(response.data.status.indicator),
                description: response.data.status.description,
                lastChecked: new Date().toISOString()
              };
            } catch (apiError) {
              console.log('Mailgun API failed, trying HTML:', apiError.message);
              
              const response = await axios.get('https://status.mailgun.com/');
              const pageText = response.data.toLowerCase();
              
              if (pageText.includes('investigating') || pageText.includes('identified')) {
                return {
                  name: 'mailgun',
                  displayName: 'Mailgun',
                  status: 'outage',
                  description: 'Service issues detected',
                  lastChecked: new Date().toISOString()
                };
              } else if (pageText.includes('monitoring') || pageText.includes('degraded')) {
                return {
                  name: 'mailgun',
                  displayName: 'Mailgun',
                  status: 'degraded',
                  description: 'Service partially affected',
                  lastChecked: new Date().toISOString()
                };
              }
              
              return {
                name: 'mailgun',
                displayName: 'Mailgun',
                status: 'operational',
                description: 'All systems operational',
                lastChecked: new Date().toISOString()
              };
            }
          } catch (error) {
            console.error('Mailgun check failed:', error.message);
            return createErrorStatus('mailgun', 'Mailgun');
          }
        }

        function determineOverallStatus(services) {
          const hasOutage = services.some(s => s.status === 'outage');
          const hasDegraded = services.some(s => s.status === 'degraded');
          const hasUnknown = services.some(s => s.status === 'unknown');
          
          if (hasOutage) return 'outage';
          if (hasDegraded) return 'degraded';
          if (hasUnknown) return 'unknown';
          return 'operational';
        }

        // Load previous status for comparison
        function loadPreviousStatus() {
          try {
            if (fs.existsSync('status.json')) {
              const data = JSON.parse(fs.readFileSync('status.json', 'utf8'));
              const previousStatus = {};
              data.services.forEach(service => {
                previousStatus[service.name] = service.status;
              });
              return { previousStatus, previousOverallStatus: data.overallStatus };
            }
          } catch (error) {
            console.log('No previous status found or error reading:', error.message);
          }
          return { previousStatus: {}, previousOverallStatus: null };
        }

        async function main() {
          console.log('=== Starting service status checks with Teams alerts ===');
          
          // Load previous status for comparison
          const { previousStatus, previousOverallStatus } = loadPreviousStatus();
          
          const services = await Promise.all([
            checkConfluentStatus(),
            checkCloudflareStatus(),
            checkNylasStatus(),
            checkSendGridStatus(),
            checkTwilioStatus(),
            checkPostmarkStatus(),
            checkZohoMailStatus(),
            checkMailgunStatus()
          ]);
          
          const currentOverallStatus = determineOverallStatus(services);
          
          const statusData = {
            services: services,
            lastUpdated: new Date().toISOString(),
            overallStatus: currentOverallStatus
          };
          
          // Check for status changes and send alerts
          let alertsSent = 0;
          const changedServices = [];
          
          for (const service of services) {
            const previousServiceStatus = previousStatus[service.name];
            
            if (previousServiceStatus && previousServiceStatus !== service.status) {
              console.log(`Status change detected for ${service.displayName}: ${previousServiceStatus} â†’ ${service.status}`);
              changedServices.push({ service, oldStatus: previousServiceStatus });
              
              // Send alert for status change
              if (service.status === 'outage' || service.status === 'degraded') {
                await sendTeamsAlert('down', service, previousServiceStatus);
                alertsSent++;
              } else if (service.status === 'operational' && 
                        (previousServiceStatus === 'outage' || previousServiceStatus === 'degraded')) {
                await sendTeamsAlert('recovered', service, previousServiceStatus);
                alertsSent++;
              }
              
              // Small delay between alerts to avoid rate limiting
              if (alertsSent > 0) {
                await new Promise(resolve => setTimeout(resolve, 1000));
              }
            }
          }
          
          // Send summary alert if there are current issues (once per hour)
          const currentHour = new Date().getHours();
          const shouldSendSummary = currentHour % 2 === 0 && new Date().getMinutes() < 10; // Every 2 hours during first 10 minutes
          
          if (shouldSendSummary) {
            const currentIssues = services.filter(s => s.status === 'outage' || s.status === 'degraded');
            if (currentIssues.length > 0 || currentOverallStatus !== 'operational') {
              await sendTeamsAlert('summary', {
                issueCount: currentIssues.length,
                totalServices: services.length
              });
            }
          }
          
          // Write to status.json
          fs.writeFileSync('status.json', JSON.stringify(statusData, null, 2));
          
          console.log('=== Status check complete ===');
          services.forEach(service => {
            const changeIndicator = previousStatus[service.name] && previousStatus[service.name] !== service.status ? ' (CHANGED)' : '';
            console.log(`- ${service.displayName}: ${service.status}${changeIndicator} - ${service.description}`);
          });
          console.log(`- Overall: ${statusData.overallStatus}`);
          console.log(`- Alerts sent: ${alertsSent}`);
        }

        main().catch(console.error);
        EOF
        
        node check-status-with-alerts.js
    
    - name: Commit and push status update
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add status.json
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Update service status - $(date -u)"
          git push
        fi
