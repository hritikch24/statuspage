# .github/workflows/update-status.yml
name: Update Service Status

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch: # Allow manual trigger
  push:
    branches: [main]

jobs:
  update-status:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Install dependencies
      run: |
        npm init -y
        npm install cheerio axios
    
    - name: Check service statuses
      run: |
        cat > check-status.js << 'EOF'
        const axios = require('axios');
        const cheerio = require('cheerio');
        const fs = require('fs');

        // Configure axios with better defaults
        axios.defaults.timeout = 15000;
        axios.defaults.headers['User-Agent'] = 'Mozilla/5.0 (compatible; StatusBot/1.0)';

        // Helper functions
        function mapStatusPageIndicator(indicator) {
          switch (indicator) {
            case 'none':
              return 'operational';
            case 'minor':
              return 'degraded';
            case 'major':
            case 'critical':
              return 'outage';
            default:
              return 'unknown';
          }
        }

        function createErrorStatus(name, displayName) {
          return {
            name: name,
            displayName: displayName,
            status: 'unknown',
            description: 'Failed to fetch official status',
            lastChecked: new Date().toISOString()
          };
        }

        // Service check functions
        async function checkConfluentStatus() {
          console.log('Checking Confluent Cloud...');
          try {
            const response = await axios.get('https://status.confluent.cloud/api/v2/status.json');
            return {
              name: 'confluent',
              displayName: 'Confluent Cloud',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Confluent check failed:', error.message);
            return createErrorStatus('confluent', 'Confluent Cloud');
          }
        }

        async function checkCloudflareStatus() {
          console.log('Checking Cloudflare...');
          try {
            const response = await axios.get('https://www.cloudflarestatus.com/api/v2/status.json');
            return {
              name: 'cloudflare',
              displayName: 'Cloudflare',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Cloudflare check failed:', error.message);
            return createErrorStatus('cloudflare', 'Cloudflare');
          }
        }

        async function checkNylasStatus() {
          console.log('Checking Nylas...');
          try {
            const response = await axios.get('https://status-v3.nylas.com/');
            const $ = cheerio.load(response.data);
            const pageText = response.data.toLowerCase();
            
            console.log('Nylas: Analyzing official status page...');
            
            // More aggressive detection for current issues
            const currentIncidentKeywords = [
              'investigating -', 'investigating:', 
              'identified -', 'identified:',
              'reopened:', 'reopened -',
              'elevated error', 'elevated 504', 'elevated 502'
            ];
            
            for (const keyword of currentIncidentKeywords) {
              if (pageText.includes(keyword)) {
                console.log(`Nylas: Found active incident keyword: ${keyword}`);
                if (keyword.includes('investigating') || keyword.includes('identified')) {
                  return {
                    name: 'nylas',
                    displayName: 'Nylas',
                    status: 'outage',
                    description: 'Currently investigating service issues',
                    lastChecked: new Date().toISOString()
                  };
                } else {
                  return {
                    name: 'nylas',
                    displayName: 'Nylas',
                    status: 'degraded',
                    description: 'Active service issues detected',
                    lastChecked: new Date().toISOString()
                  };
                }
              }
            }
            
            // Check for monitoring status
            if (pageText.includes('monitoring -') || pageText.includes('monitoring:')) {
              return {
                name: 'nylas',
                displayName: 'Nylas',
                status: 'degraded',
                description: 'Service issues being monitored',
                lastChecked: new Date().toISOString()
              };
            }
            
            // Check for very recent activity (last 3 days)
            const recentDates = ['jul 31', 'jul 30', 'jul 29', 'july 31', 'july 30', 'july 29'];
            const hasRecentActivity = recentDates.some(date => pageText.includes(date));
            
            if (hasRecentActivity && (pageText.includes('error') || pageText.includes('issue'))) {
              return {
                name: 'nylas',
                displayName: 'Nylas',
                status: 'degraded',
                description: 'Recent service issues or errors detected',
                lastChecked: new Date().toISOString()
              };
            }
            
            return {
              name: 'nylas',
              displayName: 'Nylas',
              status: 'operational',
              description: 'No active incidents detected',
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Nylas check failed:', error.message);
            return createErrorStatus('nylas', 'Nylas');
          }
        }

        async function checkSendGridStatus() {
          console.log('Checking SendGrid...');
          try {
            const response = await axios.get('https://status.sendgrid.com/api/v2/status.json');
            return {
              name: 'sendgrid',
              displayName: 'SendGrid',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('SendGrid check failed:', error.message);
            return createErrorStatus('sendgrid', 'SendGrid');
          }
        }

        async function checkTwilioStatus() {
          console.log('Checking Twilio...');
          try {
            const response = await axios.get('https://status.twilio.com/api/v2/status.json');
            return {
              name: 'twilio',
              displayName: 'Twilio Communications',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Twilio check failed:', error.message);
            return createErrorStatus('twilio', 'Twilio Communications');
          }
        }

        async function checkPostmarkStatus() {
          console.log('Checking Postmark...');
          try {
            // Try the Sorry API first
            try {
              const response = await axios.get('https://status.postmarkapp.com/api/v1/page');
              const data = response.data;
              
              let status = 'operational';
              let description = data.page?.state_text || 'All systems operational';
              
              switch (data.page?.state) {
                case 'operational':
                  status = 'operational';
                  break;
                case 'degraded':
                  status = 'degraded';
                  break;
                case 'maintenance':
                  status = 'degraded';
                  description = 'Scheduled maintenance in progress';
                  break;
                default:
                  status = 'operational';
                  break;
              }
              
              return {
                name: 'postmark',
                displayName: 'Postmark',
                status: status,
                description: description,
                lastChecked: new Date().toISOString()
              };
            } catch (apiError) {
              console.log('Postmark API failed, trying HTML:', apiError.message);
              
              // Fallback to HTML parsing
              const response = await axios.get('https://status.postmarkapp.com/');
              const $ = cheerio.load(response.data);
              const pageText = response.data.toLowerCase();
              
              if (pageText.includes('investigating') || pageText.includes('identified')) {
                return {
                  name: 'postmark',
                  displayName: 'Postmark',
                  status: 'outage',
                  description: 'Service issues detected',
                  lastChecked: new Date().toISOString()
                };
              } else if (pageText.includes('monitoring') || pageText.includes('degraded')) {
                return {
                  name: 'postmark',
                  displayName: 'Postmark',
                  status: 'degraded',
                  description: 'Service partially affected',
                  lastChecked: new Date().toISOString()
                };
              }
              
              return {
                name: 'postmark',
                displayName: 'Postmark',
                status: 'operational',
                description: 'All systems operational',
                lastChecked: new Date().toISOString()
              };
            }
          } catch (error) {
            console.error('Postmark check failed:', error.message);
            return createErrorStatus('postmark', 'Postmark');
          }
        }

        async function checkZohoMailStatus() {
          console.log('Checking Zoho Mail...');
          try {
            const response = await axios.get('https://status.zoho.com/sp/api/u/status');
            const data = response.data;
            
            console.log('Zoho API response:', JSON.stringify(data, null, 2));
            
            // Parse Zoho's API response format
            let status = 'operational';
            let description = 'All systems operational';
            
            // Check if there's any issue data in the response
            if (data.result && Array.isArray(data.result)) {
              const mailIssues = data.result.filter(item => 
                item.name && item.name.toLowerCase().includes('mail')
              );
              
              if (mailIssues.length > 0) {
                const mailIssue = mailIssues[0];
                if (mailIssue.status) {
                  switch (mailIssue.status.toLowerCase()) {
                    case 'down':
                    case 'outage':
                      status = 'outage';
                      description = 'Mail service is down';
                      break;
                    case 'degraded':
                    case 'issues':
                      status = 'degraded';
                      description = 'Mail service experiencing issues';
                      break;
                    default:
                      status = 'operational';
                      description = 'Mail service operational';
                  }
                }
              }
            }
            
            // If no specific structure, check overall status
            if (data.status) {
              switch (data.status.toLowerCase()) {
                case 'down':
                case 'outage':
                  status = 'outage';
                  description = 'Zoho services experiencing outages';
                  break;
                case 'degraded':
                case 'issues':
                  status = 'degraded';
                  description = 'Zoho services experiencing issues';
                  break;
                default:
                  status = 'operational';
                  description = 'All Zoho services operational';
              }
            }
            
            return {
              name: 'zohomail',
              displayName: 'Zoho Mail',
              status: status,
              description: description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Zoho Mail check failed:', error.message);
            console.error('Error details:', error.response?.data || error.message);
            return createErrorStatus('zohomail', 'Zoho Mail');
          }
        }

        async function checkMailgunStatus() {
          console.log('Checking Mailgun...');
          try {
            // Try API first
            try {
              const response = await axios.get('https://status.mailgun.com/api/v2/status.json');
              return {
                name: 'mailgun',
                displayName: 'Mailgun',
                status: mapStatusPageIndicator(response.data.status.indicator),
                description: response.data.status.description,
                lastChecked: new Date().toISOString()
              };
            } catch (apiError) {
              console.log('Mailgun API failed, trying HTML:', apiError.message);
              
              // Fallback to HTML parsing
              const response = await axios.get('https://status.mailgun.com/');
              const pageText = response.data.toLowerCase();
              
              if (pageText.includes('investigating') || pageText.includes('identified')) {
                return {
                  name: 'mailgun',
                  displayName: 'Mailgun',
                  status: 'outage',
                  description: 'Service issues detected',
                  lastChecked: new Date().toISOString()
                };
              } else if (pageText.includes('monitoring') || pageText.includes('degraded')) {
                return {
                  name: 'mailgun',
                  displayName: 'Mailgun',
                  status: 'degraded',
                  description: 'Service partially affected',
                  lastChecked: new Date().toISOString()
                };
              }
              
              return {
                name: 'mailgun',
                displayName: 'Mailgun',
                status: 'operational',
                description: 'All systems operational',
                lastChecked: new Date().toISOString()
              };
            }
          } catch (error) {
            console.error('Mailgun check failed:', error.message);
            return createErrorStatus('mailgun', 'Mailgun');
          }
        }

        function determineOverallStatus(services) {
          const hasOutage = services.some(s => s.status === 'outage');
          const hasDegraded = services.some(s => s.status === 'degraded');
          const hasUnknown = services.some(s => s.status === 'unknown');
          
          if (hasOutage) return 'outage';
          if (hasDegraded) return 'degraded';
          if (hasUnknown) return 'unknown';
          return 'operational';
        }

        async function main() {
          console.log('=== Starting service status checks (Official sources only) ===');
          
          const services = await Promise.all([
            checkConfluentStatus(),
            checkCloudflareStatus(),
            checkNylasStatus(),
            checkSendGridStatus(),
            checkTwilioStatus(),
            checkPostmarkStatus(),
            checkZohoMailStatus(),
            checkMailgunStatus()
          ]);
          
          const statusData = {
            services: services,
            lastUpdated: new Date().toISOString(),
            overallStatus: determineOverallStatus(services)
          };
          
          // Write to status.json
          fs.writeFileSync('status.json', JSON.stringify(statusData, null, 2));
          
          console.log('=== Status check complete ===');
          services.forEach(service => {
            console.log(`- ${service.displayName}: ${service.status} - ${service.description}`);
          });
          console.log(`- Overall: ${statusData.overallStatus}`);
        }

        main().catch(console.error);
        EOF
        
        node check-status.js
    
    - name: Commit and push status update
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git config --local user.name "GitHub Action"
        git add status.json
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Update service status - $(date -u)"
          git push
        fi