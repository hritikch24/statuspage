# .github/workflows/update-status.yml
name: Update Service Status (Product-wise)

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch: # Allow manual trigger
  push:
    branches: [main]

jobs:
  update-status:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'  # Updated to Node.js 20 for better compatibility
    
    - name: Install dependencies
      run: |
        npm init -y
        # Try different approaches for compatibility
        npm install cheerio@^1.0.0-rc.12 axios@^1.6.0 || npm install cheerio axios --legacy-peer-deps || npm install cheerio axios --force
    
    - name: Check service statuses (product-wise)
      run: |
        cat > check-status-product-wise.js << 'EOF'
        const axios = require('axios');
        const cheerio = require('cheerio');
        const fs = require('fs');

        // Configure axios with better defaults and compatibility
        const axiosConfig = {
          timeout: 15000,
          headers: {
            'User-Agent': 'Mozilla/5.0 (compatible; StatusBot/1.0)',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
          },
          maxRedirects: 5,
          validateStatus: function (status) {
            return status >= 200 && status < 500; // Accept 4xx as valid responses
          }
        };
        
        // Apply default config to axios
        Object.assign(axios.defaults, axiosConfig);

        // Helper functions
        function mapStatusPageIndicator(indicator) {
          switch (indicator) {
            case 'none':
              return 'operational';
            case 'minor':
              return 'degraded';
            case 'major':
            case 'critical':
              return 'outage';
            default:
              return 'unknown';
          }
        }

        function createErrorStatus(name, displayName) {
          return {
            name: name,
            displayName: displayName,
            status: 'unknown',
            description: 'Failed to fetch official status',
            lastChecked: new Date().toISOString()
          };
        }

        function getProductByService(serviceName) {
          const productMapping = {
            cloudflare: 'Common Infrastructure',
            azure: 'Common Infrastructure',
            nylas: 'Workplace Product',
            confluent: 'Workplace Product', 
            sendgrid: 'Workplace Product',
            twilio: 'Workplace Product',
            postmark: 'Asset Product',
            zohomail: 'Asset Product',
            mailgun: 'Asset Product'
          };
          return productMapping[serviceName] || 'Unknown Product';
        }

        async function checkConfluentStatus() {
          console.log('Checking Confluent Cloud...');
          try {
            const response = await axios.get('https://status.confluent.cloud/api/v2/status.json', {
              timeout: 10000,
              headers: { 'Accept': 'application/json' }
            });
            return {
              name: 'confluent',
              displayName: 'Confluent Cloud',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Confluent check failed:', error.message);
            return createErrorStatus('confluent', 'Confluent Cloud');
          }
        }

        async function checkCloudflareStatus() {
          console.log('Checking Cloudflare...');
          try {
            const response = await axios.get('https://www.cloudflarestatus.com/api/v2/status.json', {
              timeout: 10000,
              headers: { 'Accept': 'application/json' }
            });
            return {
              name: 'cloudflare',
              displayName: 'Cloudflare',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Cloudflare check failed:', error.message);
            return createErrorStatus('cloudflare', 'Cloudflare');
          }
        }

        async function checkAzureStatus() {
          console.log('Checking Azure Services...');
          try {
            const response = await axios.get('https://status.azure.com/en-us/status', {
              timeout: 15000,
              headers: { 'Accept': 'text/html' }
            });
            
            const $ = cheerio.load(response.data);
            const pageText = response.data.toLowerCase();
            
            console.log('Azure: Analyzing status page...');
            
            // Look for specific service outages or issues
            const serviceIssues = [];
            
            // Check for current incidents section
            $('.current-incidents, .incident-list, .service-health').each((i, el) => {
              const incidentText = $(el).text().toLowerCase();
              
              if (incidentText.includes('outage') || incidentText.includes('down')) {
                // Try to extract service names
                const serviceName = $(el).find('.service-name, .affected-service').text() || 
                                  incidentText.match(/azure (\w+)/)?.[1] || 'Unknown Service';
                serviceIssues.push(`${serviceName} - Outage`);
              } else if (incidentText.includes('degraded') || incidentText.includes('issues')) {
                const serviceName = $(el).find('.service-name, .affected-service').text() || 
                                  incidentText.match(/azure (\w+)/)?.[1] || 'Unknown Service';
                serviceIssues.push(`${serviceName} - Degraded`);
              }
            });
            
            // Check page title and main status indicators
            const pageTitle = $('title').text().toLowerCase();
            const mainStatus = $('.status-banner, .overall-status, .service-status').text().toLowerCase();
            
            // Look for current service health status
            if (pageText.includes('current service issues') || 
                pageText.includes('we are investigating') ||
                mainStatus.includes('investigating')) {
              
              // Try to find specific services mentioned
              const mentionedServices = [];
              const serviceMatches = pageText.match(/azure (\w+)/g);
              if (serviceMatches) {
                serviceMatches.forEach(match => {
                  const service = match.replace('azure ', '').trim();
                  if (!mentionedServices.includes(service)) {
                    mentionedServices.push(service);
                  }
                });
              }
              
              const description = mentionedServices.length > 0 
                ? `Issues detected: ${mentionedServices.join(', ')}`
                : 'Service issues detected - check Azure status page for details';
              
              return {
                name: 'azure',
                displayName: 'Azure Services',
                status: 'degraded',
                description: description,
                lastChecked: new Date().toISOString()
              };
            }
            
            // Check for widespread outages
            if (pageText.includes('widespread') || 
                pageText.includes('multiple services') ||
                pageText.includes('major incident')) {
              
              return {
                name: 'azure',
                displayName: 'Azure Services',
                status: 'outage',
                description: 'Major incident affecting multiple services',
                lastChecked: new Date().toISOString()
              };
            }
            
            // If we found specific service issues
            if (serviceIssues.length > 0) {
              const hasOutages = serviceIssues.some(issue => issue.includes('Outage'));
              return {
                name: 'azure',
                displayName: 'Azure Services',
                status: hasOutages ? 'outage' : 'degraded',
                description: `Issues detected: ${serviceIssues.join(', ')}`,
                lastChecked: new Date().toISOString()
              };
            }
            
            // Check if we can find any "all services operational" or similar messaging
            if (pageTitle.includes('operational') || 
                mainStatus.includes('operational') ||
                pageText.includes('all systems operational') ||
                pageText.includes('no current issues')) {
              
              return {
                name: 'azure',
                displayName: 'Azure Services',
                status: 'operational',
                description: 'All services operational',
                lastChecked: new Date().toISOString()
              };
            }
            
            // If we can successfully load the page but can't determine specific status,
            // default to operational (assume no news is good news for Azure)
            return {
              name: 'azure',
              displayName: 'Azure Services',
              status: 'operational',
              description: 'Status page accessible - no major incidents detected',
              lastChecked: new Date().toISOString()
            };
            
          } catch (error) {
            console.error('Azure check failed:', error.message);
            // If we can't reach the status page, that could indicate an issue
            return {
              name: 'azure',
              displayName: 'Azure Services',
              status: 'unknown',
              description: 'Unable to fetch Azure status page',
              lastChecked: new Date().toISOString()
            };
          }
        }

        async function checkNylasStatus() {
          console.log('Checking Nylas...');
          try {
            const response = await axios.get('https://status-v3.nylas.com/');
            const $ = cheerio.load(response.data);
            const pageText = response.data.toLowerCase();
            
            console.log('Nylas: Analyzing official status page...');
            
            const currentIncidentKeywords = [
              'investigating -', 'investigating:', 
              'identified -', 'identified:',
              'reopened:', 'reopened -',
              'elevated error', 'elevated 504', 'elevated 502'
            ];
            
            for (const keyword of currentIncidentKeywords) {
              if (pageText.includes(keyword)) {
                console.log(`Nylas: Found active incident keyword: ${keyword}`);
                if (keyword.includes('investigating') || keyword.includes('identified')) {
                  return {
                    name: 'nylas',
                    displayName: 'Nylas',
                    status: 'outage',
                    description: 'Currently investigating service issues',
                    lastChecked: new Date().toISOString()
                  };
                } else {
                  return {
                    name: 'nylas',
                    displayName: 'Nylas',
                    status: 'degraded',
                    description: 'Active service issues detected',
                    lastChecked: new Date().toISOString()
                  };
                }
              }
            }
            
            if (pageText.includes('monitoring -') || pageText.includes('monitoring:')) {
              return {
                name: 'nylas',
                displayName: 'Nylas',
                status: 'degraded',
                description: 'Service issues being monitored',
                lastChecked: new Date().toISOString()
              };
            }
            
            const recentDates = ['jul 31', 'jul 30', 'jul 29', 'july 31', 'july 30', 'july 29'];
            const hasRecentActivity = recentDates.some(date => pageText.includes(date));
            
            if (hasRecentActivity && (pageText.includes('error') || pageText.includes('issue'))) {
              return {
                name: 'nylas',
                displayName: 'Nylas',
                status: 'degraded',
                description: 'Recent service issues or errors detected',
                lastChecked: new Date().toISOString()
              };
            }
            
            return {
              name: 'nylas',
              displayName: 'Nylas',
              status: 'operational',
              description: 'No active incidents detected',
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Nylas check failed:', error.message);
            return createErrorStatus('nylas', 'Nylas');
          }
        }

        async function checkSendGridStatus() {
          console.log('Checking SendGrid...');
          try {
            const response = await axios.get('https://status.sendgrid.com/api/v2/status.json');
            return {
              name: 'sendgrid',
              displayName: 'SendGrid',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('SendGrid check failed:', error.message);
            return createErrorStatus('sendgrid', 'SendGrid');
          }
        }

        async function checkTwilioStatus() {
          console.log('Checking Twilio...');
          try {
            const response = await axios.get('https://status.twilio.com/api/v2/status.json');
            return {
              name: 'twilio',
              displayName: 'Twilio Communications',
              status: mapStatusPageIndicator(response.data.status.indicator),
              description: response.data.status.description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Twilio check failed:', error.message);
            return createErrorStatus('twilio', 'Twilio Communications');
          }
        }

        async function checkPostmarkStatus() {
          console.log('Checking Postmark...');
          try {
            try {
              const response = await axios.get('https://status.postmarkapp.com/api/v1/page');
              const data = response.data;
              
              console.log('Postmark API response:', JSON.stringify(data, null, 2));
              
              let status = 'operational';
              let description = data.page?.state_text || 'All systems operational';
              
              switch (data.page?.state) {
                case 'operational':
                  status = 'operational';
                  break;
                case 'degraded':
                  status = 'degraded';
                  break;
                case 'maintenance':
                  status = 'degraded';
                  description = 'Scheduled maintenance in progress';
                  break;
                case 'outage':
                  status = 'outage';
                  break;
                default:
                  status = 'operational';
                  description = 'All systems operational';
                  break;
              }
              
              return {
                name: 'postmark',
                displayName: 'Postmark',
                status: status,
                description: description,
                lastChecked: new Date().toISOString()
              };
            } catch (apiError) {
              console.log('Postmark API failed, trying HTML:', apiError.message);
              
              const response = await axios.get('https://status.postmarkapp.com/');
              const $ = cheerio.load(response.data);
              const pageText = response.data.toLowerCase();
              const pageTitle = $('title').text().toLowerCase();
              
              console.log('Postmark page title:', pageTitle);
              
              if (pageTitle.includes('all systems are go') || 
                  pageTitle.includes('operational') ||
                  pageText.includes('all systems are go')) {
                return {
                  name: 'postmark',
                  displayName: 'Postmark',
                  status: 'operational',
                  description: 'All systems are go!',
                  lastChecked: new Date().toISOString()
                };
              } else if (pageText.includes('investigating') || pageText.includes('identified')) {
                return {
                  name: 'postmark',
                  displayName: 'Postmark',
                  status: 'outage',
                  description: 'Service issues detected',
                  lastChecked: new Date().toISOString()
                };
              } else if (pageText.includes('monitoring') || pageText.includes('degraded')) {
                return {
                  name: 'postmark',
                  displayName: 'Postmark',
                  status: 'degraded',
                  description: 'Service partially affected',
                  lastChecked: new Date().toISOString()
                };
              }
              
              return {
                name: 'postmark',
                displayName: 'Postmark',
                status: 'operational',
                description: 'Status page accessible',
                lastChecked: new Date().toISOString()
              };
            }
          } catch (error) {
            console.error('Postmark check failed:', error.message);
            return createErrorStatus('postmark', 'Postmark');
          }
        }

        async function checkZohoMailStatus() {
          console.log('Checking Zoho Mail...');
          try {
            const response = await axios.get('https://status.zoho.com/sp/api/u/status');
            const data = response.data;
            
            console.log('Zoho API response:', JSON.stringify(data, null, 2));
            
            let status = 'operational';
            let description = 'All systems operational';
            
            if (data.result && Array.isArray(data.result)) {
              const mailIssues = data.result.filter(item => 
                item.name && item.name.toLowerCase().includes('mail')
              );
              
              if (mailIssues.length > 0) {
                const mailIssue = mailIssues[0];
                if (mailIssue.status) {
                  switch (mailIssue.status.toLowerCase()) {
                    case 'down':
                    case 'outage':
                      status = 'outage';
                      description = 'Mail service is down';
                      break;
                    case 'degraded':
                    case 'issues':
                      status = 'degraded';
                      description = 'Mail service experiencing issues';
                      break;
                    default:
                      status = 'operational';
                      description = 'Mail service operational';
                  }
                }
              }
            }
            
            if (data.status) {
              switch (data.status.toLowerCase()) {
                case 'down':
                case 'outage':
                  status = 'outage';
                  description = 'Zoho services experiencing outages';
                  break;
                case 'degraded':
                case 'issues':
                  status = 'degraded';
                  description = 'Zoho services experiencing issues';
                  break;
                default:
                  status = 'operational';
                  description = 'All Zoho services operational';
              }
            }
            
            return {
              name: 'zohomail',
              displayName: 'Zoho Mail',
              status: status,
              description: description,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Zoho Mail check failed:', error.message);
            console.error('Error details:', error.response?.data || error.message);
            return createErrorStatus('zohomail', 'Zoho Mail');
          }
        }

        async function checkMailgunStatus() {
          console.log('Checking Mailgun...');
          try {
            try {
              const response = await axios.get('https://status.mailgun.com/api/v2/status.json');
              return {
                name: 'mailgun',
                displayName: 'Mailgun',
                status: mapStatusPageIndicator(response.data.status.indicator),
                description: response.data.status.description,
                lastChecked: new Date().toISOString()
              };
            } catch (apiError) {
              console.log('Mailgun API failed, trying HTML:', apiError.message);
              
              const response = await axios.get('https://status.mailgun.com/');
              const pageText = response.data.toLowerCase();
              
              if (pageText.includes('investigating') || pageText.includes('identified')) {
                return {
                  name: 'mailgun',
                  displayName: 'Mailgun',
                  status: 'outage',
                  description: 'Service issues detected',
                  lastChecked: new Date().toISOString()
                };
              } else if (pageText.includes('monitoring') || pageText.includes('degraded')) {
                return {
                  name: 'mailgun',
                  displayName: 'Mailgun',
                  status: 'degraded',
                  description: 'Service partially affected',
                  lastChecked: new Date().toISOString()
                };
              }
              
              return {
                name: 'mailgun',
                displayName: 'Mailgun',
                status: 'operational',
                description: 'All systems operational',
                lastChecked: new Date().toISOString()
              };
            }
          } catch (error) {
            console.error('Mailgun check failed:', error.message);
            return createErrorStatus('mailgun', 'Mailgun');
          }
        }

        function determineOverallStatus(services) {
          const hasOutage = services.some(s => s.status === 'outage');
          const hasDegraded = services.some(s => s.status === 'degraded');
          const hasUnknown = services.some(s => s.status === 'unknown');
          
          if (hasOutage) return 'outage';
          if (hasDegraded) return 'degraded';
          if (hasUnknown) return 'unknown';
          return 'operational';
        }

        async function main() {
          console.log('=== Starting product-wise service status checks ===');
          
          const services = await Promise.all([
            // Common Infrastructure
            checkCloudflareStatus(),
            checkAzureStatus(),
            
            // Workplace Product
            checkConfluentStatus(),
            checkNylasStatus(),
            checkSendGridStatus(),
            checkTwilioStatus(),
            
            // Asset Product
            checkPostmarkStatus(),
            checkZohoMailStatus(),
            checkMailgunStatus()
          ]);
          
          const currentOverallStatus = determineOverallStatus(services);
          
          const statusData = {
            services: services,
            lastUpdated: new Date().toISOString(),
            overallStatus: currentOverallStatus
          };
          
          // Write to status.json
          fs.writeFileSync('status.json', JSON.stringify(statusData, null, 2));
          
          console.log('=== Product-wise status check complete ===');
          
          // Group services by product for logging
          const servicesByProduct = {
            'Common Infrastructure': services.filter(s => ['cloudflare', 'azure'].includes(s.name)),
            'Workplace Product': services.filter(s => ['nylas', 'confluent', 'sendgrid', 'twilio'].includes(s.name)),
            'Asset Product': services.filter(s => ['postmark', 'zohomail', 'mailgun'].includes(s.name))
          };
          
          Object.entries(servicesByProduct).forEach(([product, productServices]) => {
            console.log(`\n--- ${product} ---`);
            productServices.forEach(service => {
              console.log(`- ${service.displayName}: ${service.status} - ${service.description}`);
            });
          });
          
          console.log(`\n- Overall Status: ${statusData.overallStatus}`);
        }

        main().catch(console.error);
        EOF
        
        node check-status-product-wise.js
    
    - name: Commit and push status update
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add status.json
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Update service status - $(date -u)"
          git push
        fi