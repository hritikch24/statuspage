# .github/workflows/update-status.yml
name: Update Service Status

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch: # Allow manual trigger
  push:
    branches: [main]

jobs:
  update-status:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Install dependencies
      run: |
        npm init -y
        npm install cheerio axios
    
    - name: Check service statuses
      run: |
        cat > check-status.js << 'EOF'
        const axios = require('axios');
        const cheerio = require('cheerio');
        const fs = require('fs');

        // Configure axios with better defaults
        axios.defaults.timeout = 15000;
        axios.defaults.headers['User-Agent'] = 'Mozilla/5.0 (compatible; StatusBot/1.0)';

        // Helper functions
        function mapStatusPageIndicator(indicator) {
          switch (indicator) {
            case 'none':
              return 'operational';
            case 'minor':
              return 'degraded';
            case 'major':
            case 'critical':
              return 'outage';
            default:
              return 'unknown';
          }
        }

        function createErrorStatus(name, displayName) {
          return {
            name: name,
            displayName: displayName,
            officialStatus: {
              status: 'unknown',
              description: 'Failed to fetch official status'
            },
            communityStatus: {
              status: 'unknown',
              description: 'Community data unavailable'
            },
            lastChecked: new Date().toISOString()
          };
        }

        // Simplified community check using multiple sources
        async function getCommunityStatus(serviceName, alternativeNames = []) {
          const checkUrls = [
            `https://downdetector.com/status/${serviceName}`,
            `https://isdown.app/status/${serviceName}`,
            ...alternativeNames.map(name => `https://downdetector.com/status/${name}`),
            ...alternativeNames.map(name => `https://isdown.app/status/${name}`)
          ];

          for (const url of checkUrls) {
            try {
              console.log(`Checking community status: ${url}`);
              const response = await axios.get(url, { 
                timeout: 8000,
                validateStatus: status => status < 500 // Accept 4xx as valid responses
              });
              
              if (response.status === 200) {
                const pageText = response.data.toLowerCase();
                
                // Look for outage indicators
                if (pageText.includes('major outage') || 
                    pageText.includes('service down') ||
                    pageText.includes('widespread issues') ||
                    pageText.includes('currently down')) {
                  return { status: 'outage', description: 'Community reports widespread issues' };
                }
                
                // Look for problem indicators
                if (pageText.includes('problems') || 
                    pageText.includes('issues') ||
                    pageText.includes('slow') ||
                    pageText.includes('outage reports')) {
                  return { status: 'degraded', description: 'Community reports some issues' };
                }
                
                // If we can successfully parse the page, assume operational
                if (pageText.includes('no problems') || 
                    pageText.includes('operational') || 
                    pageText.includes('working normally')) {
                  return { status: 'operational', description: 'No community issues reported' };
                }
              }
            } catch (error) {
              console.log(`Community check failed for ${url}: ${error.message}`);
              continue; // Try next URL
            }
          }
          
          // If all community checks fail, return neutral status
          return { status: 'operational', description: 'Community status unavailable' };
        }

        // Service check functions
        async function checkConfluentStatus() {
          console.log('Checking Confluent Cloud...');
          try {
            const [official, community] = await Promise.all([
              // Official API
              axios.get('https://status.confluent.cloud/api/v2/status.json')
                .then(response => ({
                  status: mapStatusPageIndicator(response.data.status.indicator),
                  description: response.data.status.description
                }))
                .catch(error => {
                  console.log('Confluent API failed:', error.message);
                  return { status: 'unknown', description: 'Official API unavailable' };
                }),
              
              // Community reports
              getCommunityStatus('confluent', ['confluent-cloud'])
            ]);

            return {
              name: 'confluent',
              displayName: 'Confluent Cloud',
              officialStatus: official,
              communityStatus: community,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Confluent check failed:', error.message);
            return createErrorStatus('confluent', 'Confluent Cloud');
          }
        }

        async function checkCloudflareStatus() {
          console.log('Checking Cloudflare...');
          try {
            const [official, community] = await Promise.all([
              axios.get('https://www.cloudflarestatus.com/api/v2/status.json')
                .then(response => ({
                  status: mapStatusPageIndicator(response.data.status.indicator),
                  description: response.data.status.description
                }))
                .catch(error => {
                  console.log('Cloudflare API failed:', error.message);
                  return { status: 'unknown', description: 'Official API unavailable' };
                }),
              
              getCommunityStatus('cloudflare')
            ]);

            return {
              name: 'cloudflare',
              displayName: 'Cloudflare',
              officialStatus: official,
              communityStatus: community,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Cloudflare check failed:', error.message);
            return createErrorStatus('cloudflare', 'Cloudflare');
          }
        }

        async function checkNylasStatus() {
          console.log('Checking Nylas...');
          try {
            const [official, community] = await Promise.all([
              // Enhanced official page parsing
              axios.get('https://status-v3.nylas.com/')
                .then(response => {
                  const $ = cheerio.load(response.data);
                  const pageText = response.data.toLowerCase();
                  
                  console.log('Nylas: Analyzing official status page...');
                  
                  // More aggressive detection for current issues
                  const currentIncidentKeywords = [
                    'investigating -', 'investigating:', 
                    'identified -', 'identified:',
                    'reopened:', 'reopened -',
                    'elevated error', 'elevated 504', 'elevated 502'
                  ];
                  
                  for (const keyword of currentIncidentKeywords) {
                    if (pageText.includes(keyword)) {
                      console.log(`Nylas: Found active incident keyword: ${keyword}`);
                      if (keyword.includes('investigating') || keyword.includes('identified')) {
                        return { status: 'outage', description: 'Currently investigating service issues' };
                      } else {
                        return { status: 'degraded', description: 'Active service issues detected' };
                      }
                    }
                  }
                  
                  // Check for monitoring status
                  if (pageText.includes('monitoring -') || pageText.includes('monitoring:')) {
                    return { status: 'degraded', description: 'Service issues being monitored' };
                  }
                  
                  // Check for very recent activity (last 3 days)
                  const recentDates = ['jul 31', 'jul 30', 'jul 29', 'july 31', 'july 30', 'july 29'];
                  const hasRecentActivity = recentDates.some(date => pageText.includes(date));
                  
                  if (hasRecentActivity && (pageText.includes('error') || pageText.includes('issue'))) {
                    return { status: 'degraded', description: 'Recent service issues or errors detected' };
                  }
                  
                  return { status: 'operational', description: 'No active incidents detected' };
                })
                .catch(error => {
                  console.log('Nylas official check failed:', error.message);
                  return { status: 'unknown', description: 'Official page unavailable' };
                }),
              
              getCommunityStatus('nylas', ['nylas-api'])
            ]);

            console.log(`Nylas result - Official: ${official.status}, Community: ${community.status}`);

            return {
              name: 'nylas',
              displayName: 'Nylas',
              officialStatus: official,
              communityStatus: community,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Nylas check failed:', error.message);
            return createErrorStatus('nylas', 'Nylas');
          }
        }

        async function checkSendGridStatus() {
          console.log('Checking SendGrid...');
          try {
            const [official, community] = await Promise.all([
              axios.get('https://status.sendgrid.com/api/v2/status.json')
                .then(response => ({
                  status: mapStatusPageIndicator(response.data.status.indicator),
                  description: response.data.status.description
                }))
                .catch(error => {
                  console.log('SendGrid API failed:', error.message);
                  return { status: 'unknown', description: 'Official API unavailable' };
                }),
              
              getCommunityStatus('sendgrid', ['twilio-sendgrid'])
            ]);

            return {
              name: 'sendgrid',
              displayName: 'SendGrid',
              officialStatus: official,
              communityStatus: community,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('SendGrid check failed:', error.message);
            return createErrorStatus('sendgrid', 'SendGrid');
          }
        }

        async function checkTwilioStatus() {
          console.log('Checking Twilio...');
          try {
            const [official, community] = await Promise.all([
              axios.get('https://status.twilio.com/api/v2/status.json')
                .then(response => ({
                  status: mapStatusPageIndicator(response.data.status.indicator),
                  description: response.data.status.description
                }))
                .catch(error => {
                  console.log('Twilio API failed:', error.message);
                  return { status: 'unknown', description: 'Official API unavailable' };
                }),
              
              getCommunityStatus('twilio')
            ]);

            return {
              name: 'twilio',
              displayName: 'Twilio Communications',
              officialStatus: official,
              communityStatus: community,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Twilio check failed:', error.message);
            return createErrorStatus('twilio', 'Twilio Communications');
          }
        }

        async function checkPostmarkStatus() {
          console.log('Checking Postmark...');
          try {
            const [official, community] = await Promise.all([
              // Try multiple endpoints for Postmark
              (async () => {
                try {
                  // Try the new Sorry API first
                  const response = await axios.get('https://status.postmarkapp.com/api/v1/page');
                  const data = response.data;
                  
                  let status = 'operational';
                  let description = data.page?.state_text || 'All systems operational';
                  
                  switch (data.page?.state) {
                    case 'operational':
                      status = 'operational';
                      break;
                    case 'degraded':
                      status = 'degraded';
                      break;
                    case 'maintenance':
                      status = 'degraded';
                      description = 'Scheduled maintenance in progress';
                      break;
                    default:
                      status = 'operational';
                      break;
                  }
                  
                  return { status, description };
                } catch (apiError) {
                  console.log('Postmark API failed, trying HTML:', apiError.message);
                  
                  // Fallback to HTML parsing
                  const response = await axios.get('https://status.postmarkapp.com/');
                  const $ = cheerio.load(response.data);
                  const pageText = response.data.toLowerCase();
                  
                  if (pageText.includes('investigating') || pageText.includes('identified')) {
                    return { status: 'outage', description: 'Service issues detected' };
                  } else if (pageText.includes('monitoring') || pageText.includes('degraded')) {
                    return { status: 'degraded', description: 'Service partially affected' };
                  }
                  
                  return { status: 'operational', description: 'All systems operational' };
                }
              })(),
              
              getCommunityStatus('postmark', ['postmark-app'])
            ]);

            return {
              name: 'postmark',
              displayName: 'Postmark',
              officialStatus: official,
              communityStatus: community,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Postmark check failed:', error.message);
            return createErrorStatus('postmark', 'Postmark');
          }
        }

        async function checkZohoMailStatus() {
          console.log('Checking Zoho Mail...');
          try {
            const [official, community] = await Promise.all([
              axios.get('https://zohostatus.com/')
                .then(response => {
                  const $ = cheerio.load(response.data);
                  const pageText = response.data.toLowerCase();
                  
                  // Look for Mail-specific issues
                  if (pageText.includes('mail') && (pageText.includes('down') || pageText.includes('outage'))) {
                    return { status: 'outage', description: 'Mail service experiencing issues' };
                  } else if (pageText.includes('mail') && (pageText.includes('degraded') || pageText.includes('slow'))) {
                    return { status: 'degraded', description: 'Mail service experiencing performance issues' };
                  } else if (pageText.includes('all systems operational') || pageText.includes('no issues')) {
                    return { status: 'operational', description: 'All systems operational' };
                  }
                  
                  // Default to operational if we can load the page
                  return { status: 'operational', description: 'No specific mail issues detected' };
                })
                .catch(error => {
                  console.log('Zoho official check failed:', error.message);
                  return { status: 'unknown', description: 'Official page unavailable' };
                }),
              
              getCommunityStatus('zoho', ['zoho-mail'])
            ]);

            return {
              name: 'zohomail',
              displayName: 'Zoho Mail',
              officialStatus: official,
              communityStatus: community,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Zoho Mail check failed:', error.message);
            return createErrorStatus('zohomail', 'Zoho Mail');
          }
        }

        async function checkMailgunStatus() {
          console.log('Checking Mailgun...');
          try {
            const [official, community] = await Promise.all([
              // Try API first, fallback to HTML
              (async () => {
                try {
                  const response = await axios.get('https://status.mailgun.com/api/v2/status.json');
                  return {
                    status: mapStatusPageIndicator(response.data.status.indicator),
                    description: response.data.status.description
                  };
                } catch (apiError) {
                  console.log('Mailgun API failed, trying HTML:', apiError.message);
                  
                  // Fallback to HTML parsing
                  const response = await axios.get('https://status.mailgun.com/');
                  const pageText = response.data.toLowerCase();
                  
                  if (pageText.includes('investigating') || pageText.includes('identified')) {
                    return { status: 'outage', description: 'Service issues detected' };
                  } else if (pageText.includes('monitoring') || pageText.includes('degraded')) {
                    return { status: 'degraded', description: 'Service partially affected' };
                  }
                  
                  return { status: 'operational', description: 'All systems operational' };
                }
              })(),
              
              getCommunityStatus('mailgun')
            ]);

            return {
              name: 'mailgun',
              displayName: 'Mailgun',
              officialStatus: official,
              communityStatus: community,
              lastChecked: new Date().toISOString()
            };
          } catch (error) {
            console.error('Mailgun check failed:', error.message);
            return createErrorStatus('mailgun', 'Mailgun');
          }
        }

        function determineOverallStatus(services) {
          const hasOfficialOutage = services.some(s => s.officialStatus?.status === 'outage');
          const hasCommunityOutage = services.some(s => s.communityStatus?.status === 'outage');
          const hasOfficialDegraded = services.some(s => s.officialStatus?.status === 'degraded');
          const hasCommunityDegraded = services.some(s => s.communityStatus?.status === 'degraded');
          const hasUnknown = services.some(s => 
            s.officialStatus?.status === 'unknown' && s.communityStatus?.status === 'unknown'
          );
          
          if (hasOfficialOutage || hasCommunityOutage) return 'outage';
          if (hasOfficialDegraded || hasCommunityDegraded) return 'degraded';
          if (hasUnknown) return 'unknown';
          return 'operational';
        }

        async function main() {
          console.log('=== Starting service status checks ===');
          
          const services = await Promise.all([
            checkConfluentStatus(),
            checkCloudflareStatus(),
            checkNylasStatus(),
            checkSendGridStatus(),
            checkTwilioStatus(),
            checkPostmarkStatus(),
            checkZohoMailStatus(),
            checkMailgunStatus()
          ]);
          
          const statusData = {
            services: services,
            lastUpdated: new Date().toISOString(),
            overallStatus: determineOverallStatus(services)
          };
          
          // Write to status.json
          fs.writeFileSync('status.json', JSON.stringify(statusData, null, 2));
          
          console.log('=== Status check complete ===');
          services.forEach(service => {
            console.log(`- ${service.displayName}:`);
            console.log(`  Official: ${service.officialStatus?.status || 'unknown'}`);
            console.log(`  Community: ${service.communityStatus?.status || 'unknown'}`);
          });
          console.log(`- Overall: ${statusData.overallStatus}`);
        }

        main().catch(console.error);
        EOF
        
        node check-status.js
    
    - name: Commit and push status update
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add status.json
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Update service status - $(date -u)"
          git push
        fi